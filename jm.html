<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>加密工具</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        body {
            background: linear-gradient(135deg, #6e8efb, #a777e3);
            color: #333;
            min-height: 100vh;
            padding: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
        }
        .container {
            width: 100%;
            max-width: 600px;
            padding: 10px 0;
        }
        header {
            text-align: center;
            margin-bottom: 25px;
            color: white;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        h1 {
            font-size: 1.8rem;
            margin-bottom: 8px;
        }
        header p {
            font-size: 0.9rem;
            opacity: 0.9;
        }
        .page {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            width: 100%;
            min-height: calc(100vh - 120px);
            display: flex;
            flex-direction: column;
        }
        .encrypt-wrapper h2 {
            font-size: 1.2rem;
            margin-bottom: 18px;
            color: #444;
            border-left: 3px solid #6e8efb;
            padding-left: 10px;
        }
        .encrypt-inner {
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 100%;
        }
        .encrypt-textarea-group {
            width: 100%;
        }
        textarea {
            width: 100%;
            min-height: 180px;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 0.9rem;
            resize: vertical;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.05);
            transition: border-color 0.3s;
            margin-bottom: 5px;
        }
        textarea:focus {
            outline: none;
            border-color: #6e8efb;
            box-shadow: inset 0 1px 3px rgba(110, 142, 251, 0.2);
        }
        .encrypt-input-group {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        input, select {
            width: 100%;
            padding: 12px 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 0.9rem;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.05);
            transition: border-color 0.3s;
        }
        input:focus, select:focus {
            outline: none;
            border-color: #6e8efb;
            box-shadow: inset 0 1px 3px rgba(110, 142, 251, 0.2);
        }
        input[disabled] {
            background-color: #f8f8f8;
            color: #888;
        }
        .encrypt-input-group .btn-group {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-top: 5px;
        }
        button {
            padding: 14px;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 1rem;
            font-weight: 500;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        button:active {
            transform: translateY(0);
        }
        .upload-btn {
            background: #a777e3;
        }
        .upload-btn:hover {
            background: #9165d1;
        }
        .encrypt-btn {
            background: #6e8efb;
        }
        .encrypt-btn:hover {
            background: #5a7de3;
        }
        .decrypt-btn {
            background: #52c41a;
        }
        .decrypt-btn:hover {
            background: #46a017;
        }
        .status-indicator {
            padding: 10px 12px;
            border-radius: 8px;
            font-size: 0.85rem;
            font-weight: 500;
            text-align: center;
            display: none;
            margin-top: 5px;
        }
        .status-success {
            background: #f6ffed;
            border: 1px solid #b7eb8f;
            color: #52c41a;
            display: block;
        }
        .status-error {
            background: #fff2f0;
            border: 1px solid #ffccc7;
            color: #ff4d4f;
            display: block;
        }
        #fileUpload {
            display: none;
        }
        /* 文件类型提示（手机端醒目） */
        .file-tip {
            font-size: 0.8rem;
            color: #666;
            margin-top: -8px;
            margin-bottom: 5px;
            text-align: right;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>加密工具</h1>
            <p>支持文本/JSON文件加密解密</p>
        </header>
        <div id="encrypt-page" class="page">
            <div class="encrypt-wrapper">
                <h2>TVBox AES-128-CBC加密</h2>
                <div class="encrypt-inner">
                    <!-- 输入文本区 -->
                    <div class="encrypt-textarea-group">
                        <textarea id="jsonData" placeholder=""></textarea>

                    </div>

                    <!-- 操作区 -->
                    <div class="encrypt-input-group">
                        <select id="selectValue">
                            <option value="1">加密</option>
                            <option value="0">解密</option>
                        </select>
                        <input id="key" value="123456" maxlength="16" type="text" placeholder="KEY/密码（必填）">
                        <input id="iv" maxlength="13" type="text" placeholder="IV/向量（自动生成）" disabled>
                        
                        <div class="btn-group">
                            <button class="upload-btn" onclick="handleUploadClick()">上传文件</button>
                            <input type="file" id="fileUpload" accept=".txt,.json" onchange="handleFileUpload(event)">
                            <button class="encrypt-btn" id="encryptBtn" onclick="encryptAes()">加密并下载</button>
                            <button class="decrypt-btn" id="decryptBtn" onclick="decryptAes()" style="display: none">解密</button>
                        </div>

                        <div id="statusIndicator" class="status-indicator"></div>
                    </div>

                    <!-- 结果文本区 -->
                    <div class="encrypt-textarea-group">
                        <textarea id="result" placeholder="" readonly></textarea>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // DOM元素获取
        const jsonDataElem = document.getElementById('jsonData');
        const keyElem = document.getElementById('key');
        const ivElem = document.getElementById('iv');
        const selectValueElem = document.getElementById('selectValue');
        const resultElem = document.getElementById('result');
        const encryptBtn = document.getElementById('encryptBtn');
        const decryptBtn = document.getElementById('decryptBtn');
        const statusIndicator = document.getElementById('statusIndicator');

        // 初始化IV
        ivElem.value = new Date().getTime();

        // 切换加密/解密按钮
        selectValueElem.addEventListener('change', () => {
            if (selectValueElem.value === '1') {
                encryptBtn.style.display = 'block';
                decryptBtn.style.display = 'none';
            } else {
                encryptBtn.style.display = 'none';
                decryptBtn.style.display = 'block';
            }
        });

        // 16字节补位工具函数
        function padTo16Byte(str) {
            return CryptoJS.enc.Utf8.parse(str.toString().padEnd(16, '0'));
        }

        // AES加密核心函数
        function Encrypt(word, keyStr, ivStr) {
            const key = padTo16Byte(keyStr);
            const iv = padTo16Byte(ivStr);
            const encrypted = CryptoJS.AES.encrypt(word, key, { iv });
            return encrypted.ciphertext.toString(CryptoJS.enc.Hex);
        }

        // AES解密核心函数
        function decryptAesBCB(encryptedData) {
            const dataArr = encryptedData.split("");
            const prefixCode = CryptoJS.enc.Utf8.parse("$#").toString();
            const suffixCode = CryptoJS.enc.Utf8.parse("#$").toString();
            const pwdMix = dataArr.splice(0, encryptedData.indexOf(suffixCode) + 4).join("");
            const roundtimeInHax = dataArr.splice(dataArr.length - 26, 26).join("");
            const encryptedText = dataArr.join("");
            const pwdInHax = pwdMix.substring(prefixCode.length, pwdMix.length - suffixCode.length);
            const roundTime = CryptoJS.enc.Utf8.stringify(CryptoJS.enc.Hex.parse(roundtimeInHax));
            const pwd = CryptoJS.enc.Utf8.stringify(CryptoJS.enc.Hex.parse(pwdInHax));
            const iv = CryptoJS.enc.Utf8.parse(roundTime.padEnd(16, "0"));
            const pkBlocks = CryptoJS.enc.Utf8.parse(pwd.padEnd(16, "0"));
            const cipherParams = CryptoJS.lib.CipherParams.create({
                ciphertext: CryptoJS.enc.Hex.parse(encryptedText),
            });
            return CryptoJS.enc.Utf8.stringify(
                CryptoJS.AES.decrypt(cipherParams, pkBlocks, {
                    iv: iv,
                    mode: CryptoJS.mode.CBC,
                    padding: CryptoJS.pad.Pkcs7,
                })
            );
        }

        // 状态提示
        function setStatus(message, type) {
            statusIndicator.textContent = message;
            statusIndicator.className = 'status-indicator';
            statusIndicator.classList.add(type === 'success' ? 'status-success' : 'status-error');
            setTimeout(() => {
                statusIndicator.textContent = '';
                statusIndicator.className = 'status-indicator';
            }, 3000);
        }

        // 加密下载函数（支持JSON格式输出）
        function encryptAes() {
            const jsonData = jsonDataElem.value.trim();
            const key = keyElem.value.trim();
            const iv = ivElem.value;

            if (!jsonData) {
                setStatus("", "error");
                jsonDataElem.focus();
                return;
            }
            if (!key || key.length > 16) {
                setStatus("KEY/密码不能为空且不超过16位", "error");
                keyElem.focus();
                return;
            }

            try {
                // 尝试解析为JSON（若输入是JSON，加密前转为字符串）
                let content = jsonData;
                try {
                    const parsedJson = JSON.parse(jsonData);
                    content = JSON.stringify(parsedJson); // 标准化JSON格式
                } catch (e) {
                    // 非JSON格式，直接使用原文本
                }

                const resultData = Encrypt(content, key, iv);
                const keyHex = CryptoJS.enc.Hex.stringify(CryptoJS.enc.Utf8.parse(`$#${key}#$`));
                const ivHex = CryptoJS.enc.Hex.stringify(CryptoJS.enc.Utf8.parse(iv));
                const finalResult = `${keyHex}${resultData}${ivHex}`;
                
                resultElem.value = finalResult;

                // 下载文件：若原内容是JSON，下载文件后缀设为.json
                let fileName = `file.txt`;
                try {
                    JSON.parse(jsonData);
                    fileName = `file.json`;
                } catch (e) {}

                const blob = new Blob([finalResult], { type: "text/plain;charset=utf-8" });
                const url = URL.createObjectURL(blob);
                const link = document.createElement("a");
                link.href = url;
                link.download = fileName;
                link.click();
                URL.revokeObjectURL(url);

                setStatus("加密成功！文件已下载", "success");
            } catch (err) {
                resultElem.value = "";
                setStatus("加密失败：" + err.message, "error");
            }
        }

        // 解密函数（支持JSON格式解析）
        function decryptAes() {
            const jsonData = jsonDataElem.value.trim();

            if (!jsonData) {
                setStatus("", "error");
                jsonDataElem.focus();
                return;
            }

            try {
                const decryptedResult = decryptAesBCB(jsonData);
                // 尝试格式化JSON（若解密结果是JSON，美化显示）
                let displayResult = decryptedResult;
                try {
                    const parsedJson = JSON.parse(decryptedResult);
                    displayResult = JSON.stringify(parsedJson, null, 2); // 带缩进，手机端更易读
                } catch (e) {
                    // 非JSON格式，直接显示
                }
                resultElem.value = displayResult;
                setStatus("解密成功！可复制结果", "success");
            } catch (err) {
                resultElem.value = "";
                setStatus("解密失败：" + err.message, "error");
            }
        }

        // 上传文件触发
        function handleUploadClick() {
            document.getElementById('fileUpload').click();
        }

        // 文件上传处理（支持.txt和.json）
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            // 校验文件类型（仅允许txt和json）
            const allowedTypes = ['text/plain', 'application/json'];
            const allowedExts = ['.txt', '.json'];
            const fileExt = file.name.slice(-4).toLowerCase();
            if (!allowedTypes.includes(file.type) && !allowedExts.includes(fileExt)) {
                setStatus("仅支持文本文件（.txt）和JSON文件（.json）", "error");
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                const fileContent = e.target.result;
                // 若为JSON文件，尝试解析并格式化显示（手机端更易读）
                try {
                    const parsedJson = JSON.parse(fileContent);
                    jsonDataElem.value = JSON.stringify(parsedJson, null, 2);
                } catch (e) {
                    // 非JSON文件（或JSON格式错误），直接显示原内容
                    jsonDataElem.value = fileContent;
                }
                setStatus(`文件上传成功：${file.name}`, "success");
                resultElem.value = "";
            };
            reader.onerror = () => {
                setStatus("文件读取失败，请重试", "error");
            };
            reader.readAsText(file);
        }
    </script>
</body>
</html>
